import { promises as fs } from "node:fs";
import path from "node:path";
import { normalizePath } from "../src/shared/normalize-path.mjs";

const CONTENT_ROOT = path.join(process.cwd(), "src", "content", "pages");
const PUBLIC_ROOT = path.join(process.cwd(), "public");
const GENERATED_MARKER = "<!-- generated by scripts/generate-redirects.mjs -->";

function slugFromFilePath(filePath) {
  const relativePath = path.relative(CONTENT_ROOT, filePath);
  const withoutExtension = relativePath.replace(/\.mdx$/, "");

  if (withoutExtension === "index") {
    return "";
  }

  if (withoutExtension.endsWith("/index")) {
    return withoutExtension.slice(0, -"/index".length);
  }

  return withoutExtension;
}

function redirectDocument(fromPath, toPath) {
  return `<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta http-equiv="refresh" content="0; url=${toPath}" />\n    <link rel="canonical" href="${toPath}" />\n    <title>Redirecting...</title>\n  </head>\n  <body>\n    <p>Redirecting to <a href="${toPath}">${toPath}</a>.</p>\n    ${GENERATED_MARKER}\n    <p>Legacy path: <code>${fromPath}</code></p>\n  </body>\n</html>\n`;
}

async function findFiles(rootDirectory, extension) {
  const files = [];
  const pending = [rootDirectory];

  while (pending.length > 0) {
    const current = pending.pop();
    const entries = await fs.readdir(current, { withFileTypes: true });

    for (const entry of entries) {
      const absolutePath = path.join(current, entry.name);
      if (entry.isDirectory()) {
        pending.push(absolutePath);
        continue;
      }

      if (entry.isFile() && absolutePath.endsWith(extension)) {
        files.push(absolutePath);
      }
    }
  }

  return files;
}

async function collectRedirects() {
  const redirects = new Map();
  const mdxFiles = await findFiles(CONTENT_ROOT, ".mdx");

  for (const filePath of mdxFiles) {
    const slug = slugFromFilePath(filePath);
    if (!slug) {
      continue;
    }

    const canonicalPath = normalizePath(`/${slug}`);
    const canonicalWithoutSlash = canonicalPath.slice(0, -1);
    redirects.set(`${canonicalWithoutSlash}.html`, canonicalPath);

    if (slug.includes("/")) {
      const leafName = slug.split("/").pop();
      const flatLegacyPath = `/${leafName}.html`;
      const existingTarget = redirects.get(flatLegacyPath);

      if (existingTarget && existingTarget !== canonicalPath) {
        throw new Error(
          `Duplicate redirect source ${flatLegacyPath} for ${existingTarget} and ${canonicalPath}`
        );
      }

      redirects.set(flatLegacyPath, canonicalPath);
    }
  }

  return new Map([...redirects.entries()].sort(([left], [right]) => left.localeCompare(right)));
}

async function removeStaleGeneratedRedirects(validRedirectPaths) {
  const htmlFiles = await findFiles(PUBLIC_ROOT, ".html");

  for (const filePath of htmlFiles) {
    const contents = await fs.readFile(filePath, "utf8");
    if (!contents.includes(GENERATED_MARKER)) {
      continue;
    }

    const publicRelativePath = `/${path.relative(PUBLIC_ROOT, filePath).replaceAll(path.sep, "/")}`;
    if (!validRedirectPaths.has(publicRelativePath)) {
      await fs.unlink(filePath);
    }
  }
}

async function writeRedirects(redirects) {
  for (const [fromPath, toPath] of redirects) {
    const filePath = path.join(PUBLIC_ROOT, fromPath.replace(/^\//, ""));
    await fs.mkdir(path.dirname(filePath), { recursive: true });
    await fs.writeFile(filePath, redirectDocument(fromPath, toPath));
  }
}

async function main() {
  const redirects = await collectRedirects();
  await removeStaleGeneratedRedirects(new Set(redirects.keys()));
  await writeRedirects(redirects);
  console.log(`Generated ${redirects.size} redirect files.`);
}

await main();
